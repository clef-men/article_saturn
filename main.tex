\documentclass[a4paper, 11pt]{article}

\usepackage[top=0.7in, bottom=0.7in]{geometry}

%------------------------------------------------------------

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

%------------------------------------------------------------

\usepackage[style=numeric, sorting=ynt, doi=false, maxnames=10]{biblatex}
\addbibresource{main.bib}

%------------------------------------------------------------

\usepackage{macros}

%------------------------------------------------------------

\title{\Saturn: a library of verified parallelisme-safe data structures for \OCaml~5}
\date{\today}
\author{
  ClÃ©ment Allain (INRIA) \\
  Vesa Karvonen (Tarides) \\
  Carine Morel (Tarides)
}

%------------------------------------------------------------
%------------------------------------------------------------

\begin{document}

\maketitle

\section{Abstract}

We present \Saturn, a new \OCaml~5 library available on \opam.
\Saturn offers a collection of parallelism-safe efficient data structures: stack, queue, skiplist, hash table, work-stealing deque, etc.
It is well tested, benchmarked and in part formally verified.

\section{Motivation}

Sharing data between multiple threads or cores is a well-known problem.
A naive approach is to take a sequential data structure and protect it with a lock.
However, this is often not the best solution.
First, if performance is a concern, this approach is likely to be inefficient as locks introduce significant contention.
Second, it may not be a sound solution as it can lead to liveness issues such as deadlock, starvation and priority inversion.

In contrast, \emph{lock-free} implementations relying on fine-grained synchronisation rather than locks are typically faster and guaranty system-wide progress.
Yet, they are also more complex and come with their own set of bugs: ABA problem (largely mitigated in garbage-collected languages), data races, unexpected behaviors due to non-linearizability.

In this context, \Saturn provides a collection of standard lock-free data structures saving \OCaml~5 programmers the trouble of designing their own.

\section{Library design}

\Saturn aims at covering a wide range of use cases, from simple stacks and queues to more complex data structures like skiplists and hash tables.
More precisely, it currently features:
(A) numerous queues: a queue based on the well-known Michael-Scott queue~\cite{michael1996simple}, a single-producer single-consumer queue, a multiple-producer single-consumer queue and a bounded queue; 
(B) a stack based on the Treiber stack~\cite{treiber1986systems};
(C) a work-stealing deque;
(D) a bag;
(E) a hash table;
(F) a skiplist.

% How we choose the data structures and algorithms
Most implementations are based on well-known algorithms.
They have been adapted to work with and take advantage of the \OCaml~5 memory model.
For instance, we had to rework the Michael-Scott queue to avoid memory leak.

% Safe/unsafe versions
Regarding performance, \Saturn provides benchmarks for each data structure, and significant effort has been dedicated to optimizations.
For instance, we work on preventing false sharing. False sharing occurs when several shared data are contained in a single cache line. 
When different domains simultaneously access these data items, they are forced to synchronize, even if they are not modifying the same data.
To avoid it, we need to ensure that shared data items are not in the same cache line, which essentially requires padding them.
Currently, in \OCaml~5 only atomic variables can be padded (using \texttt{Atomic.make\_contended}, available since \OCaml 5.2.0), but it is often useful to do more and \OCaml~5 is missing such a feature.

% The single-consumer single-producer queue provides a good example of this issue: 

% \emph{Add code snippet to show the issue}.

There are other missing features in \OCaml~5, such as the inability to remove fences on atomic accesses, even when they are redundant with the preceding and/or following atomic accesses.
Additionally, there is the issue of extra indirection in arrays of atomics: each cell in such an array is a pointer to an atomic, which is itself another pointer with fences. This part of the work done in \Saturn is also motivated by the need to highlight these limitations and to suggest possible improvements to the \OCaml~5 memory model and compiler.

% However, there is often a tension between improving efficiency and remaining within the safe fragment of \OCaml~5.

To explore optimizations that bypass these current limitations, we use unsafe features of the language (e.g., \texttt{Obj.magic}). Although these optimizations are performed with care and should not break anything under regular use, we cannot provide the same level of guarantee as with the standard implementations. Consequently, some of \Saturn's data structures have two versions: a version using only the available features of \OCaml and another utilizing the \texttt{Obj} module to achieve optimizations that are currently unattainable otherwise. While most users should find the regular version efficient enough for their needs, more adventurous users may prefer the optimized version, provided they encapsulate it correctly and thoroughly verify their code.


% \section{Example of use}
% It feels it would be nice to have a simple example here to show that it is easy to use the library.

% TODO Possible question :  
% - When it should not be used ?  
%   - composability -> see Kcas
%   - very specific needs and performance
% - Is it ready ?

\section{Tests}

In multicore programming, it is essential to test not only the safety of the data structures but also to verify sequential consistency and lock-freedom when expected.
To achieve this, \Saturn has been thoroughly tested using two primary different tools: \DSCheck and \STM.

\STM is used not only for unit testing but also for verifying sequential consistency.
It automatically generates random full programs using the provided API---in the case of \Saturn, a data structure.
These programs are executed in two domains and all results are checked against the post-conditions of each function, providing unit testing.
Simultaneously, \STM verifies sequential consistency by ensuring that all intermediate states can be explained by a sequential execution of the calls.

\DSCheck is a model checker.
It is designed to compute all possible interleavings of a given program and verify that each one returns the expected result.
This is particularly useful for catching elusive bugs that occur only in specific, rare interleavings.
Additionally, \DSCheck can be used to verify that a program is lock-free, as it will fail to terminate if any form of blocking is present.

\section{Formal verification}

Lock-free algorithms are notoriously difficult to get right.
To provide stronger guarantees, we have verified part of \Saturn's data structures and aim at covering the entire library.
Moreover, one important benefit is that we get formal specifications for verified data structures.

This verification effort has been conducted using \Iris~\cite{DBLP:journals/jfp/JungKJBBD18}, a state-of-the-art mechanized \emph{concurrent separation logic}.
In particular, all proofs are formalized in \Coq.

A common criterion to specify concurrent operations on shared data structures is \emph{linearizability}.
The equivalent \Iris notion is \emph{logical atomicity}: there exists a point in time when a concurrent operation atomically takes effect (the linearization point).
This statement takes the form of an \emph{atomic specification}:

\[
  \aspec{
    \mathrm{queue \mathhyphen inv}\ t
  }{
    \mathit{vs}
  }{
    \mathrm{queue \mathhyphen model}\ t\  \mathit{vs}
  }{
    \texttt{queue\_push}\ t\ v
  }{
    \mathrm{queue \mathhyphen model}\ t\  (\mathit{vs} \mdoubleplus [v])
  }{
    \texttt{()}
  }{
    \mathrm{True}
  }
\]

In this example, we specify the \texttt{queue\_push} operation from an implementation of a concurrent queue.
Similarly to \href{https://en.wikipedia.org/wiki/Hoare_logic}{Hoare triples}, the two assertions inside curly brackets express the precondition and postcondition.
Here, the $\mathrm{queue \mathhyphen inv}\ t$ precondition represents the queue invariant.
As it is persistent, we do not need to give it back in the postcondition.
The other two assertions inside angle brackets express the \emph{atomic precondition} and \emph{atomic postcondition}.
Basically, they specify the linearization point of the operation: during the execution of \texttt{queue\_push}, the logical model of the queue is atomically updated from $\mathit{vs}$ to $\mathit{vs} \mdoubleplus [v]$, in other words $v$ is atomically pushed at the back of the queue.

As a final note, we emphasize that our verification assumes a sequentially consistent memory model.
Nevertheless, \OCaml~5's relaxed memory model has been formalized~\cite{DBLP:journals/pacmpl/MevelJP20} in \Iris.
It should be possible and is future work to adapt our specifications and proofs to support it.

% \section{Futur work}
% By providing extensively tested, formally verified, and benchmarked parallelism-safe implementations, \Saturn aims to help \OCaml~5 users avoid the pitfalls and intricacies of implementing their own concurrent data structures. The library is available on \opam and is under active development. We plan to add new data structures (such as a lock-free priority queue, a bounded stack, and a lock-free set, among others) and continue improving the existing ones. Additionally, we are working on formally verifying even more data structures using \Iris. 

\section{Talk proposal}

In our talk, we will introduce \Saturn, including the main data structures and design guidelines.
We will also discuss ongoing work on verifying the library using the \Iris concurrent separation logic.


\printbibliography

\end{document}
